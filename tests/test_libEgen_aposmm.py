"""
Optimization of a 2D function with APOSMM/nlopt.

Export options can also be tested.
"""

import os
from math import gamma, pi, sqrt
import numpy as np
import libensemble.gen_funcs
libensemble.gen_funcs.rc.aposmm_optimizers = "nlopt"

from libensemble.gen_classes import APOSMM
from optimas.generators import ExternalGenerator
from libensemble.tools import add_unique_random_streams

from gest_api.vocs import VOCS
from optimas.evaluators import TemplateEvaluator
from optimas.explorations import Exploration


def analyze_simulation(simulation_directory, output_params):
    """
    Analyze the simulation output.
    This method analyzes the output generated by the simulation to
    obtain the value of the optimization objective and other analyzed
    parameters, if specified. The value of these parameters has to be
    given to the `output_params` dictionary.

    Parameters
    ----------

    simulation_directory : str
        Path to the simulation folder where the output was generated.
    output_params : dict
        Dictionary where the value of the objectives and analyzed parameters
        will be stored. There is one entry per parameter, where the key
        is the name of the parameter given by the user.

    Returns
    -------

    dict
        The `output_params` dictionary with the results from the analysis.
    """
    # Read back result from file
    with open("result.txt") as f:
        result = float(f.read())
    # Fill in output parameters.
    output_params["f"] = result
    return output_params


def test_aposmm_nlopt():
    """Test APOSMM/nlopt with a 2D function."""
    initial_sample_size = 8
    max_evals = 40
    n = 2  # dimensions

    # Create varying parameters and objectives.
    vocs = VOCS(
        variables= {
            "x0": [-3.0, 3.0],
            "x1": [-2.0, 2.0],
            "x0_on_cube": [0, 1.0],
            "x1_on_cube": [0, 1.0],
        },
        objectives={
            "f": "MINIMIZE"
        },
    )

    # How APOSMM will convert the variables to internal arrays.
    variables_mapping = {
        "x": ["x0", "x1"],
        "x_on_cube": [
            "x0_on_cube",
            "x1_on_cube",
        ],
    }

    aposmm = APOSMM(
        vocs=vocs,
        variables_mapping=variables_mapping,
        initial_sample_size=initial_sample_size,
        localopt_method="LN_BOBYQA",
        rk_const=0.5 * ((gamma(1 + (n / 2)) * 5) ** (1 / n)) / sqrt(pi),
        xtol_abs=1e-6,
        ftol_abs=1e-6,
        dist_to_bound_multiple=0.5,
        max_active_runs=4,  # refers to APOSMM's simul local optimization runs
    )

    # Create generator.
    gen = ExternalGenerator(
        ext_gen=aposmm,
        vocs=vocs,
        save_model=True,
    )

    # Create evaluator.
    ev = TemplateEvaluator(
        sim_template=os.path.join(
            os.path.abspath(os.path.dirname(__file__)),
            "resources",
            "template_simulation_script.py",
        ),
        analysis_func=analyze_simulation,
    )

    # Create exploration.
    exp = Exploration(
        generator=gen,
        evaluator=ev,
        max_evals=max_evals,
        sim_workers=4,
        run_async=True,
        exploration_dir_path="./tests_output/test_libEgen_aposmm",
    )

    # Run exploration
    exp.run()

    if exp.is_manager:
        aposmm.finalize()

        # Get data in gen format and in user format
        H, persis_info, _ = aposmm.export()

        # Check sampling followed by optimization runs
        assert not np.any(H["local_pt"][:initial_sample_size])
        assert np.all(H["local_pt"][initial_sample_size:])


if __name__ == "__main__":
    test_aposmm_nlopt()
